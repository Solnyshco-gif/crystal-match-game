<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Match</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --cell: 45px;
            --gem: 35px;
            --gap: 4px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body { background: var(--bg); color: white; font-family: 'Arial', sans-serif; overflow: hidden; height: 100vh; }

        /* === LOADER === */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg); z-index: 9999; display: flex; flex-direction: column;
            align-items: center; justify-content: center; gap: 20px; transition: opacity 0.6s ease;
        }
        .logo {
            width: 80px; height: 80px; background: radial-gradient(circle, #FFD166, #FF6B6B);
            border-radius: 50%; box-shadow: 0 0 30px rgba(255,215,102,0.8);
            animation: pulse 1.5s infinite;
        }
        .loader-text {
            font-size: 18px; font-weight: bold; letter-spacing: 2px;
            background: linear-gradient(90deg, #FFD166, #FF6B6B); -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .loader-bar {
            width: 200px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;
        }
        .loader-fill {
            width: 0%; height: 100%; background: linear-gradient(90deg, #FFD166, #FF6B6B);
            border-radius: 2px; transition: width 0.3s ease;
        }

        /* === CONTAINER === */
        .container { display: none; flex-direction: column; align-items: center; padding: 10px; height: 100%; }
        .header { display: flex; justify-content: space-between; width: 100%; max-width: 500px; margin-bottom: 10px;
            background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
        .stats { display: flex; flex-direction: column; gap: 5px; }
        .stat-item { display: flex; align-items: center; gap: 8px; font-size: 14px; font-weight: bold; }
        .stat-value { background: rgba(255,255,255,0.2); padding: 4px 12px; border-radius: 15px; min-width: 60px; text-align: center; }

        /* === BOARD === */
        #game-board {
            display: grid; grid-template-columns: repeat(8, 1fr); gap: var(--gap);
            background: rgba(0,0,0,0.3); border-radius: 15px; padding: 8px;
        }
        .cell {
            width: var(--cell); height: var(--cell); background: rgba(255,255,255,0.1);
            border-radius: 12px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; position: relative; overflow: hidden;
        }
        .gem {
            width: var(--gem); height: var(--gem); border-radius: 10px;
            background: linear-gradient(135deg, #FF6B6B, #FF8E8E);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); transition: all 0.3s ease;
            position: relative;
        }
        .gem::after {
            content: ''; position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px;
            background: linear-gradient(135deg, rgba(255,255,255,0.4), transparent);
            border-radius: 8px;
        }
        .gem.selected { transform: scale(1.2); box-shadow: 0 0 25px gold; z-index: 10; }
        .gem-1 { background: linear-gradient(135deg, #FF6B6B, #FF8E8E); }
        .gem-2 { background: linear-gradient(135deg, #4ECDC4, #88D9E6); }
        .gem-3 { background: linear-gradient(135deg, #FFD166, #FFE8A3); }
        .gem-4 { background: linear-gradient(135deg, #06D6A0, #6AFFD6); }
        .gem-5 { background: linear-gradient(135deg, #118AB2, #5BC0EB); }
        .gem-6 { background: linear-gradient(135deg, #9B5DE5, #C78FFF); }
        .gem-7 { background: linear-gradient(135deg, #F15BB5, #FFA8E0); }

        /* === ANIMATIONS === */
        @keyframes pulse { 0%,100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        @keyframes explode { to { transform: scale(0); opacity: 0; } }
        @keyframes fall { from { transform: translateY(-150px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes spawn { 0% { transform: scale(0) rotate(-180deg); } 70% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes combo-pop { 0% { transform: translate(-50%,-50%) scale(0.5); opacity: 0; } 50% { transform: translate(-50%,-50%) scale(1.2); opacity: 1; } 100% { transform: translate(-50%,-120%) scale(0.8); opacity: 0; } }
        @keyframes particle { to { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; } }

        .gem.exploding { animation: explode 0.5s ease-out forwards; }
        .gem.falling { animation: fall 0.5s ease-in; }
        .gem.spawning { animation: spawn 0.5s ease-out; }
        .combo-popup { position: absolute; font-weight: bold; color: gold; font-size: 22px; pointer-events: none; z-index: 100; animation: combo-pop 1s ease-out forwards; }
        .particle { position: absolute; width: 6px; height: 6px; border-radius: 50%; pointer-events: none; animation: particle 0.8s ease-out forwards; }

        /* === UI === */
        .controls { display: flex; gap: 15px; margin-top: 15px; }
        .btn { padding: 12px 25px; border: none; border-radius: 20px; font-weight: bold; cursor: pointer; transition: all 0.3s; }
        .btn:hover { transform: translateY(-2px); }
        .btn-primary { background: linear-gradient(135deg, #FF6B6B, #FF8E8E); color: white; box-shadow: 0 8px 20px rgba(255,107,107,0.4); }
        .btn-premium { background: linear-gradient(135deg, #FFD166, #FFE8A3); color: #333; box-shadow: 0 8px 20px rgba(255,209,102,0.4); }
        .progress-bar { height: 12px; background: linear-gradient(90deg, #FF6B6B, #4ECDC4, #118AB2); border-radius: 10px; width: 0%; transition: width 0.5s ease; }

        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(10px); }
        .modal-content { background: var(--bg); padding: 30px; border-radius: 25px; text-align: center; max-width: 90%; box-shadow: 0 25px 50px rgba(0,0,0,0.5); animation: modal-appear 0.5s ease-out; }
        @keyframes modal-appear { from { transform: scale(0.7) translateY(50px); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        @media (max-width: 500px) {
            :root { --cell: 35px; --gem: 28px; }
            .btn { padding: 10px 20px; font-size: 14px; }
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<!-- === LOADER === -->
<div id="loader">
    <div class="logo"></div>
    <div class="loader-text">CRYSTAL MATCH</div>
    <div class="loader-bar"><div class="loader-fill" id="loader-fill"></div></div>
</div>

<!-- === MAIN GAME === -->
<div class="container" id="game-container">
    <div class="header">
        <div class="stats">
            <div class="stat-item">Очки: <div class="stat-value" id="score">0</div></div>
            <div class="stat-item">Ходы: <div class="stat-value" id="moves">25</div></div>
            <div class="stat-item">Уровень: <div class="stat-value" id="level">1</div></div>
        </div>
        <div class="stats">
            <div class="stat-item">Цель: <div class="stat-value" id="target">1000</div></div>
            <div class="stat-item">Комбо: <div class="stat-value" id="combo">x1</div></div>
        </div>
    </div>

    <div style="background: rgba(255,255,255,0.05); border-radius: 25px; padding: 15px; box-shadow: 0 20px 40px rgba(0,0,0,0.4); backdrop-filter: blur(15px);">
        <div id="game-board"></div>
    </div>

    <div style="width: 100%; max-width: 500px; margin: 15px 0; background: rgba(255,255,255,0.1); border-radius: 15px; padding: 8px;">
        <div class="progress-bar" id="progress-bar"></div>
    </div>

    <div class="controls">
        <button class="btn btn-primary" id="hint-btn">Подсказка</button>
        <button class="btn btn-premium" id="premium-btn">ПРЕМИУМ</button>
        <button class="btn btn-primary" id="restart-btn">Заново</button>
    </div>
</div>

<!-- === WIN MODAL === -->
<div id="win-modal" class="modal hidden">
    <div class="modal-content">
        <h2>Победа!</h2>
        <p>Уровень пройден!</p>
        <p>Очки: <span id="final-score">0</span></p>
        <p>Комбо: x<span id="final-combo">1</span></p>
        <button class="btn btn-primary" id="next-level-btn">Далее</button>
    </div>
</div>

<script>
/* ========================================
   MAIN - Инициализация и глобальные переменные
   ======================================== */
const tg = window.Telegram.WebApp;
tg.expand(); tg.BackButton.hide();

const BOARD_SIZE = 8, GEM_TYPES = 7;
const LEVEL_TARGETS = [1000, 2500, 5000, 10000, 20000];
const LEVEL_MOVES = [25, 22, 20, 18, 15];

const state = {
    board: [], score: 0, moves: 25, level: 1, target: 1000,
    combo: 1, comboMul: 1, selected: null, animating: false,
    premium: false, started: false
};

const el = {
    loader: document.getElementById('loader'),
    loaderFill: document.getElementById('loader-fill'),
    container: document.getElementById('game-container'),
    board: document.getElementById('game-board'),
    score: document.getElementById('score'),
    moves: document.getElementById('moves'),
    level: document.getElementById('level'),
    target: document.getElementById('target'),
    combo: document.getElementById('combo'),
    progress: document.getElementById('progress-bar'),
    winModal: document.getElementById('win-modal'),
    finalScore: document.getElementById('final-score'),
    finalCombo: document.getElementById('final-combo'),
    hintBtn: document.getElementById('hint-btn'),
    premiumBtn: document.getElementById('premium-btn'),
    restartBtn: document.getElementById('restart-btn'),
    nextBtn: document.getElementById('next-level-btn')
};

/* ========================================
   GAME - Логика игры
   ======================================== */
function createBoard() {
    state.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++) {
            let type;
            do type = Math.floor(Math.random() * GEM_TYPES) + 1;
            while (hasMatchAt(r, c, type));
            state.board[r][c] = type;
        }
    if (!hasPossibleMoves()) createBoard();
}

function hasMatchAt(r, c, t) {
    return (c >= 2 && state.board[r][c-1] === t && state.board[r][c-2] === t) ||
           (r >= 2 && state.board[r-1][c] === t && state.board[r-2][c] === t);
}

function renderBoard() {
    el.board.innerHTML = '';
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++) {
            const type = state.board[r][c];
            if (!type) continue;
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.r = r; cell.dataset.c = c;
            const gem = document.createElement('div');
            gem.className = `gem gem-${type}`;
            cell.appendChild(gem);
            el.board.appendChild(cell);
            cell.onclick = () => handleClick(r, c);
        }
}

function handleClick(r, c) {
    if (state.animating || state.moves <= 0) return;
    if (!state.started) state.started = true;

    const gem = { r, c, type: state.board[r][c] };
    if (!state.selected) {
        state.selected = gem;
        selectGem(r, c);
    } else if (isNeighbor(state.selected, gem)) {
        state.animating = true;
        swapGems(state.selected, gem).then(ok => {
            if (ok) { state.moves--; updateUI(); checkWin(); }
            state.selected = null; state.animating = false;
        });
    } else {
        clearSelection(); state.selected = gem; selectGem(r, c);
    }
}

function isNeighbor(a, b) {
    return Math.abs(a.r - b.r) + Math.abs(a.c - b.c) === 1;
}

function selectGem(r, c) {
    const gem = document.querySelector(`[data-r="${r}"][data-c="${c}"] .gem`);
    if (gem) gem.classList.add('selected');
}

function clearSelection() {
    document.querySelectorAll('.gem.selected').forEach(g => g.classList.remove('selected'));
}

/* ========================================
   ANIMATIONS - Анимации
   ======================================== */
async function swapGems(g1, g2) {
    const c1 = document.querySelector(`[data-r="${g1.r}"][data-c="${g1.c}"]`);
    const c2 = document.querySelector(`[data-r="${g2.r}"][data-c="${g2.c}"]`);
    const r1 = c1.getBoundingClientRect(), r2 = c2.getBoundingClientRect();
    const dx = r2.left - r1.left, dy = r2.top - r1.top;

    const gem1 = c1.querySelector('.gem'), gem2 = c2.querySelector('.gem');
    gem1.style.position = gem2.style.position = 'fixed';
    gem1.style.left = r1.left + 'px'; gem1.style.top = r1.top + 'px';
    gem2.style.left = r2.left + 'px'; gem2.style.top = r2.top + 'px';
    gem1.style.zIndex = gem2.style.zIndex = 100;

    requestAnimationFrame(() => {
        gem1.style.transform = `translate(${dx}px, ${dy}px)`;
        gem2.style.transform = `translate(${-dx}px, ${-dy}px)`;
    });

    await sleep(300);
    [state.board[g1.r][g1.c], state.board[g2.r][g2.c]] = [state.board[g2.r][g2.c], state.board[g1.r][g1.c]];
    renderBoard();

    const matches = findMatches();
    if (matches.length) {
        await processMatches(matches);
        return true;
    } else {
        [state.board[g1.r][g1.c], state.board[g2.r][g2.c]] = [state.board[g2.r][g2.c], state.board[g1.r][g1.c]];
        renderBoard();
        return false;
    }
}

function findMatches() {
    const matches = [], visited = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(false));
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (visited[r][c] || !state.board[r][c]) continue;
            const t = state.board[r][c];
            let h = 1, v = 1;
            while (c + h < BOARD_SIZE && state.board[r][c + h] === t) h++;
            while (r + v < BOARD_SIZE && state.board[r + v][c] === t) v++;
            if (h >= 3) { matches.push({r, c, len: h, hor: true, t}); for (let i=0;i<h;i++) visited[r][c+i]=true; }
            if (v >= 3) { matches.push({r, c, len: v, hor: false, t}); for (let i=0;i<v;i++) visited[r+i][c]=true; }
        }
    return matches;
}

async function processMatches(matches) {
    state.comboMul += 0.2; state.combo = Math.floor(state.comboMul * 10) / 10;
    let score = 0;
    matches.forEach(m => {
        score += m.len * 100 * state.combo;
        for (let i = 0; i < m.len; i++) {
            const r = m.hor ? m.r : m.r + i;
            const c = m.hor ? m.c + i : m.c;
            explodeGem(r, c);
        }
        showCombo(m);
    });
    state.score += Math.floor(score);
    await sleep(600);
    await dropGems();
    await spawnGems();
    const next = findMatches();
    if (next.length) await processMatches(next);
    else { state.combo = 1; state.comboMul = 1; }
    updateUI();
}

function explodeGem(r, c) {
    const cell = document.querySelector(`[data-r="${r}"][data-c="${c}"]`);
    if (!cell) return;
    const gem = cell.querySelector('.gem');
    gem.classList.add('exploding');
    createParticles(cell);
    setTimeout(() => { state.board[r][c] = 0; }, 300);
}

function createParticles(cell) {
    const r = cell.getBoundingClientRect();
    const cx = r.left + r.width/2, cy = r.top + r.height/2;
    const color = getComputedStyle(cell.querySelector('.gem')).background;
    for (let i = 0; i < 10; i++) {
        const p = document.createElement('div');
        p.className = 'particle';
        p.style.background = color;
        p.style.left = cx + 'px'; p.style.top = cy + 'px';
        const a = Math.random() * Math.PI * 2, d = 30 + Math.random() * 60;
        p.style.setProperty('--tx', Math.cos(a)*d + 'px');
        p.style.setProperty('--ty', Math.sin(a)*d + 'px');
        document.body.appendChild(p);
        setTimeout(() => p.remove(), 800);
    }
}

function showCombo(m) {
    const cell = document.querySelector(`[data-r="${m.r}"][data-c="${m.c}"]`);
    const r = cell.getBoundingClientRect();
    const pop = document.createElement('div');
    pop.className = 'combo-popup';
    pop.textContent = `x${state.combo}!`;
    pop.style.left = (r.left + r.width/2) + 'px';
    pop.style.top = (r.top + r.height/2) + 'px';
    document.body.appendChild(pop);
    setTimeout(() => pop.remove(), 1000);
}

async function dropGems() {
    let moved = false;
    for (let c = 0; c < BOARD_SIZE; c++) {
        let wp = BOARD_SIZE - 1;
        for (let r = BOARD_SIZE - 1; r >= 0; r--) {
            if (state.board[r][c]) {
                if (r !== wp) {
                    state.board[wp][c] = state.board[r][c];
                    state.board[r][c] = 0;
                    moved = true;
                    setTimeout(() => {
                        const gem = document.querySelector(`[data-r="${wp}"][data-c="${c}"] .gem`);
                        if (gem) gem.classList.add('falling');
                    }, 50);
                }
                wp--;
            }
        }
    }
    if (moved) { renderBoard(); await sleep(500); }
}

async function spawnGems() {
    let spawned = false;
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++)
            if (state.board[r][c] === 0) {
                state.board[r][c] = Math.floor(Math.random() * GEM_TYPES) + 1;
                spawned = true;
                setTimeout(() => {
                    const gem = document.querySelector(`[data-r="${r}"][data-c="${c}"] .gem`);
                    if (gem) gem.classList.add('spawning');
                }, 100);
            }
    if (spawned) { renderBoard(); await sleep(500); }
}

/* ========================================
   UTILS - Вспомогательные функции
   ======================================== */
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

function hasPossibleMoves() {
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (c < BOARD_SIZE-1 && testSwap(r,c,r,c+1)) return true;
            if (r < BOARD_SIZE-1 && testSwap(r,c,r+1,c)) return true;
        }
    return false;
}
function testSwap(r1,c1,r2,c2) {
    [state.board[r1][c1], state.board[r2][c2]] = [state.board[r2][c2], state.board[r1][c1]];
    const ok = findMatches().length > 0;
    [state.board[r1][c1], state.board[r2][c2]] = [state.board[r2][c2], state.board[r1][c1]];
    return ok;
}

function updateUI() {
    el.score.textContent = state.score;
    el.moves.textContent = state.moves;
    el.level.textContent = state.level;
    el.target.textContent = state.target;
    el.combo.textContent = `x${state.combo}`;
    el.progress.style.width = Math.min(state.score / state.target * 100, 100) + '%';
}

function checkWin() {
    if (state.started && state.score >= state.target) showWin();
    else if (state.moves <= 0 && state.started) {
        setTimeout(() => { alert('Ходы закончились!'); resetGame(); }, 500);
    }
}

function showWin() {
    el.finalScore.textContent = state.score;
    el.finalCombo.textContent = state.combo;
    el.winModal.classList.remove('hidden');
}

function nextLevel() {
    state.level++;
    state.target = LEVEL_TARGETS[state.level-1] || state.level * 2000;
    state.moves = LEVEL_MOVES[state.level-1] || 15;
    state.score = 0; state.combo = 1; state.comboMul = 1; state.started = false;
    createBoard(); renderBoard(); updateUI();
    el.winModal.classList.add('hidden');
}

function resetGame() {
    state.score = 0; state.moves = LEVEL_MOVES[state.level-1] || 25;
    state.combo = 1; state.comboMul = 1; state.started = false;
    createBoard(); renderBoard(); updateUI();
    el.winModal.classList.add('hidden');
}

function showHint() {
    if (state.animating || state.moves <= 0) return;
    for (let r = 0; r < BOARD_SIZE; r++)
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (c < BOARD_SIZE-1 && testSwap(r,c,r,c+1)) { pulse(r,c,r,c+1); return; }
            if (r < BOARD_SIZE-1 && testSwap(r,c,r+1,c)) { pulse(r,c,r+1,c); return; }
        }
}
function pulse(r1,c1,r2,c2) {
    const cells = [document.querySelector(`[data-r="${r1}"][data-c="${c1}"]`), document.querySelector(`[data-r="${r2}"][data-c="${c2}"]`)];
    cells.forEach(cell => cell && (cell.style.animation = 'pulse 1s infinite'));
    setTimeout(() => cells.forEach(cell => cell && (cell.style.animation = '')), 2000);
}

/* ========================================
   PREMIUM - Премиум и реклама
   ======================================== */
function checkPremium() {
    setTimeout(() => {
        if (tg.initDataUnsafe.user?.id % 10 === 0) {
            state.premium = true;
            el.premiumBtn.textContent = 'ПРЕМИУМ';
        }
    }, 100);
}

el.premiumBtn.onclick = () => tg.showPopup({
    title: 'Премиум', message: 'Без рекламы, бесконечные подсказки!',
    buttons: [{id:'buy',type:'default',text:'299₽/мес'}, {type:'cancel'}]
}, btn => btn === 'buy' && tg.openInvoice('https://example.com/invoice'));

setInterval(() => {
    if (!state.premium && !document.querySelector('.modal:not(.hidden)')) {
        console.log('Реклама...');
    }
}, 60000);

/* ========================================
   INIT - Запуск игры
   ======================================== */
function startGame() {
    createBoard(); renderBoard(); updateUI(); checkPremium();
    el.container.style.display = 'flex';
    el.loader.style.opacity = '0';
    setTimeout(() => el.loader.remove(), 600);
}

// Симуляция загрузки
let load = 0;
const interval = setInterval(() => {
    load += 10 + Math.random() * 15;
    el.loaderFill.style.width = Math.min(load, 100) + '%';
    if (load >= 100) { clearInterval(interval); setTimeout(startGame, 300); }
}, 150);

/* === СОБЫТИЯ === */
el.hintBtn.onclick = showHint;
el.restartBtn.onclick = resetGame;
el.nextBtn.onclick = nextLevel;

</script>
</body>
</html>
